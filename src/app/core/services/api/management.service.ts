/**
 * TWMS REST API
 * TWMS REST API
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AssignDeviceToFunctionInput } from '../model/assignDeviceToFunctionInput';
import { DevicePointOutputDto } from '../model/devicePointOutputDto';
import { ForbiddenResponse } from '../model/forbiddenResponse';
import { FunctionDto } from '../model/functionDto';
import { FunctionTypes } from '../model/functionTypes';
import { FunctionsInput } from '../model/functionsInput';
import { InvalidModelStateResponse } from '../model/invalidModelStateResponse';
import { ProblemDetails } from '../model/problemDetails';
import { RemoveDeviceFromFunctionInput } from '../model/removeDeviceFromFunctionInput';
import { SetDisabledTimestampFunctionInput } from '../model/setDisabledTimestampFunctionInput';
import { TemperatureLevelObject } from '../model/temperatureLevelObject';
import { UnauthorizedResponse } from '../model/unauthorizedResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ManagementService {

    protected basePath = '/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Assign a device to a existing function
     *  Example update parameter:   &lt;pre&gt;  {       \&quot;functionName\&quot; : \&quot;My flush schedule interval\&quot;,       \&quot;devicePointUuid\&quot; : \&quot;dec1ceb01d7aaabea7eaaaaaaaaa0001\&quot;,       \&quot;isHighPriority\&quot; : false  }   &lt;/pre&gt;
     * @param body Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assignFlushableDevicePointToFunction(body: AssignDeviceToFunctionInput, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public assignFlushableDevicePointToFunction(body: AssignDeviceToFunctionInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public assignFlushableDevicePointToFunction(body: AssignDeviceToFunctionInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public assignFlushableDevicePointToFunction(body: AssignDeviceToFunctionInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling assignFlushableDevicePointToFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Functions/Management/assignFlushableDevicePoint`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a function
     *  Example create parameter: (see https://collab.cbb.de/confluence/display/CIT/CreateFunction+backend+endpoint+description for more details)   &lt;pre&gt;  {   \&quot;name\&quot;: \&quot;My hygiene flush (fix interval)\&quot;,   \&quot;type\&quot;: \&quot;hygieneFlush\&quot;,   \&quot;disabledTimestamp\&quot;: \&quot;2022-04-12T08:00:00.000000\&quot;,   \&quot;legacy\&quot;: false,   \&quot;remark\&quot;: \&quot;my remark\&quot;,   \&quot;flushableDevicePointUuids\&quot;: [       \&quot;dec1ceb01d7aaabea7eaaaaaaaaa0001\&quot;,       \&quot;dec1ceb01d7aaac1ad71caaaaaaa0001\&quot;,        \&quot;dec1ceb01d7aaafa11eaaaaaaaaa0001\&quot;    ],    \&quot;flushSchedule\&quot;: {       \&quot;fixIntervalFlushPlan\&quot;: {           \&quot;startDateUtc\&quot;: \&quot;2018-04-12T08:00:00.000000\&quot;,            \&quot;intervalHours\&quot;: 72         }     }  }   &lt;/pre&gt;
     * @param body Configuration of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createFunction(body: FunctionsInput, observe?: 'body', reportProgress?: boolean): Observable<FunctionDto>;
    public createFunction(body: FunctionsInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FunctionDto>>;
    public createFunction(body: FunctionsInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FunctionDto>>;
    public createFunction(body: FunctionsInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FunctionDto>('post',`${this.basePath}/v1/Functions/Management`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a function
     * 
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFunction(functionName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteFunction(functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteFunction(functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteFunction(functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling deleteFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/Functions/Management/${encodeURIComponent(String(functionName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Executes a component test
     * 
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeComponentTest(functionName: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: boolean; }>;
    public executeComponentTest(functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: boolean; }>>;
    public executeComponentTest(functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: boolean; }>>;
    public executeComponentTest(functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling executeComponentTest.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: boolean; }>('patch',`${this.basePath}/v1/Functions/Management/componentTest/${encodeURIComponent(String(functionName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Executes a function test (e.g. start hygiene flush)
     * 
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeFunctionTest(functionName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public executeFunctionTest(functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public executeFunctionTest(functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public executeFunctionTest(functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling executeFunctionTest.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Functions/Management/functionTest/${encodeURIComponent(String(functionName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all compatible devices point for target function type
     * 
     * @param functionTypeName Function Type Name like: hygieneFlush, circulation or thermalDisinfection
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllCompatibleDevicePointsForTargetFunction(functionTypeName: FunctionTypes, observe?: 'body', reportProgress?: boolean): Observable<Array<DevicePointOutputDto>>;
    public getAllCompatibleDevicePointsForTargetFunction(functionTypeName: FunctionTypes, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DevicePointOutputDto>>>;
    public getAllCompatibleDevicePointsForTargetFunction(functionTypeName: FunctionTypes, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DevicePointOutputDto>>>;
    public getAllCompatibleDevicePointsForTargetFunction(functionTypeName: FunctionTypes, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionTypeName === null || functionTypeName === undefined) {
            throw new Error('Required parameter functionTypeName was null or undefined when calling getAllCompatibleDevicePointsForTargetFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DevicePointOutputDto>>('get',`${this.basePath}/v1/Functions/Management/getallcompatibledevicepoints/${encodeURIComponent(String(functionTypeName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all functions
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllFunctions(observe?: 'body', reportProgress?: boolean): Observable<Array<FunctionDto>>;
    public getAllFunctions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FunctionDto>>>;
    public getAllFunctions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FunctionDto>>>;
    public getAllFunctions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<FunctionDto>>('get',`${this.basePath}/v1/Functions/Management`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all compatible functions for a target device
     * 
     * @param uuid devicePointUUID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompatibleFunctionsForDevice(uuid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FunctionDto>>;
    public getCompatibleFunctionsForDevice(uuid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FunctionDto>>>;
    public getCompatibleFunctionsForDevice(uuid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FunctionDto>>>;
    public getCompatibleFunctionsForDevice(uuid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getCompatibleFunctionsForDevice.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<FunctionDto>>('get',`${this.basePath}/v1/Functions/Management/GetCompatibleFunctionsForDevice/${encodeURIComponent(String(uuid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a function
     * 
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFunction(functionName: string, observe?: 'body', reportProgress?: boolean): Observable<FunctionDto>;
    public getFunction(functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FunctionDto>>;
    public getFunction(functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FunctionDto>>;
    public getFunction(functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling getFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FunctionDto>('get',`${this.basePath}/v1/Functions/Management/${encodeURIComponent(String(functionName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all device point related functions
     * 
     * @param uuid Uuid of the device point
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFunctionsForDevicePoint(uuid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FunctionDto>>;
    public getFunctionsForDevicePoint(uuid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FunctionDto>>>;
    public getFunctionsForDevicePoint(uuid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FunctionDto>>>;
    public getFunctionsForDevicePoint(uuid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getFunctionsForDevicePoint.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<FunctionDto>>('get',`${this.basePath}/v1/Functions/Management/functionsForDevice/${encodeURIComponent(String(uuid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * https://collab.cbb.de/confluence/display/TWMS/Software+Lastenheft+%7C+TWMS+1#SoftwareLastenheft|TWMS1-12b.Funktionen-Zirkulation  (FA-TWMS-12b-1 | Ändern der Betriebstemperaturen der Trinkwasseranlage warm (PWH)/Einstellen der Zirkulationsregulierventile auf andere Temperaturen)  1. 60°C/55°C  2. 55°C/50°C  3. 48°C/45°C  4. manual config ϑ PWH/ϑ PWH-C min
     * 
     * @param dteDevicePointUuid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTemperatureLevelsForCirculation(dteDevicePointUuid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TemperatureLevelObject>>;
    public getTemperatureLevelsForCirculation(dteDevicePointUuid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TemperatureLevelObject>>>;
    public getTemperatureLevelsForCirculation(dteDevicePointUuid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TemperatureLevelObject>>>;
    public getTemperatureLevelsForCirculation(dteDevicePointUuid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dteDevicePointUuid === null || dteDevicePointUuid === undefined) {
            throw new Error('Required parameter dteDevicePointUuid was null or undefined when calling getTemperatureLevelsForCirculation.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<TemperatureLevelObject>>('get',`${this.basePath}/v1/Functions/Management/circulationtemperaturelevels/${encodeURIComponent(String(dteDevicePointUuid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assign a device to a existing function
     *  Example update parameter:   &lt;pre&gt;  {       \&quot;functionName\&quot; : \&quot;My flush schedule interval\&quot;,       \&quot;devicePointUuid\&quot; : \&quot;dec1ceb01d7aaabea7eaaaaaaaaa0001\&quot;  }   &lt;/pre&gt;
     * @param body Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeFlushableDeviceFromFunction(body: RemoveDeviceFromFunctionInput, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeFlushableDeviceFromFunction(body: RemoveDeviceFromFunctionInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeFlushableDeviceFromFunction(body: RemoveDeviceFromFunctionInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeFlushableDeviceFromFunction(body: RemoveDeviceFromFunctionInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling removeFlushableDeviceFromFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Functions/Management/removeFlushableDevicePoint`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Activates a function
     * 
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetDisabledTimestamp(functionName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetDisabledTimestamp(functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetDisabledTimestamp(functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetDisabledTimestamp(functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling resetDisabledTimestamp.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Functions/Management/resetDisabledTimestamp/${encodeURIComponent(String(functionName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deactivates a function
     *  Example update parameter:   &lt;pre&gt;  {       \&quot;functionName\&quot;: \&quot;My flush schedule interval\&quot;,       \&quot;disabledTimestamp\&quot;: \&quot;2022-04-12T09:00:00.000000\&quot;  }   &lt;/pre&gt;
     * @param body Uuid of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setDisabledTimestamp(body: SetDisabledTimestampFunctionInput, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setDisabledTimestamp(body: SetDisabledTimestampFunctionInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setDisabledTimestamp(body: SetDisabledTimestampFunctionInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setDisabledTimestamp(body: SetDisabledTimestampFunctionInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setDisabledTimestamp.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Functions/Management/setDisabledTimestamp`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a function
     *  Example update parameter:   &lt;pre&gt;  {   \&quot;name\&quot;: \&quot;My hygiene flush (fix interval) updated\&quot;,   \&quot;type\&quot;: \&quot;hygieneFlush\&quot;,   \&quot;disabledTimestamp\&quot;: \&quot;2022-04-12T08:00:00.000000\&quot;,   \&quot;legacy\&quot;: false,   \&quot;remark\&quot;: \&quot;my remark\&quot;,   \&quot;flushableDevicePointUuids\&quot;: [       \&quot;dec1ceb01d7aaabea7eaaaaaaaaa0001\&quot;,       \&quot;dec1ceb01d7aaac1ad71caaaaaaa0001\&quot;,        \&quot;dec1ceb01d7aaafa11eaaaaaaaaa0001\&quot;    ],    \&quot;flushSchedule\&quot;: {       \&quot;fixIntervalFlushPlan\&quot;: {           \&quot;startDateUtc\&quot;: \&quot;2018-04-12T08:00:00.000000\&quot;,            \&quot;intervalHours\&quot;: 72         }     }  }   &lt;/pre&gt;
     * @param body New configuration for the function
     * @param functionName Name of the function
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFunction(body: FunctionsInput, functionName: string, observe?: 'body', reportProgress?: boolean): Observable<FunctionDto>;
    public updateFunction(body: FunctionsInput, functionName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FunctionDto>>;
    public updateFunction(body: FunctionsInput, functionName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FunctionDto>>;
    public updateFunction(body: FunctionsInput, functionName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateFunction.');
        }

        if (functionName === null || functionName === undefined) {
            throw new Error('Required parameter functionName was null or undefined when calling updateFunction.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FunctionDto>('patch',`${this.basePath}/v1/Functions/Management/${encodeURIComponent(String(functionName))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
