/**
 * TWMS REST API
 * TWMS REST API
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ForbiddenResponse } from '../model/forbiddenResponse';
import { ODataOutput } from '../model/oDataOutput';
import { OutputDataType } from '../model/outputDataType';
import { ProblemDetails } from '../model/problemDetails';
import { ReportDataQueryOutputDto } from '../model/reportDataQueryOutputDto';
import { ReportOptionsQueryResultDto } from '../model/reportOptionsQueryResultDto';
import { UnauthorizedResponse } from '../model/unauthorizedResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ItemReportsFilterService {

    protected basePath = '/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get all filter categories (e.g. uuid, typeName, ...)
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCategories(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getCategories(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getCategories(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getCategories(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/v1/Reports/Filter/options`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Select data via filter options. Returns table with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, DataPointId, Value
     * Example  &lt;pre&gt;  {   \&quot;devicePointUuid\&quot;:\&quot;8953641b732467a4d07372d45eb05abc\&quot;,   \&quot;typeName\&quot;:\&quot;DTE\&quot;,   \&quot;DataPointId\&quot;:\&quot;4\&quot;,   \&quot;dateUTCMin\&quot;:\&quot;2019-03-04T11:28:18.000000\&quot;   \&quot;dateUTCMax\&quot;:\&quot;2019-03-04T11:28:18.000000\&quot;,   \&quot;offset\&quot;:\&quot;10\&quot;,   \&quot;limit\&quot;:\&quot;5\&quot;,   \&quot;order\&quot;:\&quot;asc\&quot;  }  &lt;/pre&gt;
     * @param device_point_name uuid of the device point which created this data point
     * @param device_point_uuid uuid of the device point which created this data point
     * @param device_uuid name of the device, e.g. \&quot;Wall-E 2\&quot;
     * @param device_type_name type of the device, e.g. \&quot;Wall-E\&quot;
     * @param data_point_id number of the channel, e.g. 6 (6 &#x3D; Temperature_Get, see enum ChannelValueCodes or emico c api)
     * @param data_point_description channel description, e.g. Get Temperature
     * @param data_point_unit channel unit, e.g. DegC
     * @param date_utc_min 
     * @param date_utc_max Consider only datalog elements with date less or equal DateUTCMax
     * @param date_utc_offset_base 
     * @param date_offset_sec Alternative option to set DateUTCMin and DateUTCMax  Only in combination with DateUTC
     * @param value_min Value should be greater equal ValueMin  if we want to allow negatives values, we have to change the generator constaint \&quot;if (valueMin lower 0.0) then\&quot;
     * @param value_max Value should be lower equal ValueMax
     * @param DataType Desired Datatype
     * @param VirtualInitValue should include virtual initial value  if no DataPoint matches filter criteria the last DataPoint befor selected timeframe is given
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataQuery(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ReportDataQueryOutputDto>>;
    public getDataQuery(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ReportDataQueryOutputDto>>>;
    public getDataQuery(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ReportDataQueryOutputDto>>>;
    public getDataQuery(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (device_point_name !== undefined && device_point_name !== null) {
            queryParameters = queryParameters.set('device_point_name', <any>device_point_name);
        }
        if (device_point_uuid !== undefined && device_point_uuid !== null) {
            queryParameters = queryParameters.set('device_point_uuid', <any>device_point_uuid);
        }
        if (device_uuid !== undefined && device_uuid !== null) {
            queryParameters = queryParameters.set('device_uuid', <any>device_uuid);
        }
        if (device_type_name !== undefined && device_type_name !== null) {
            queryParameters = queryParameters.set('device_type_name', <any>device_type_name);
        }
        if (data_point_id !== undefined && data_point_id !== null) {
            queryParameters = queryParameters.set('data_point_id', <any>data_point_id);
        }
        if (data_point_description !== undefined && data_point_description !== null) {
            queryParameters = queryParameters.set('data_point_description', <any>data_point_description);
        }
        if (data_point_unit !== undefined && data_point_unit !== null) {
            queryParameters = queryParameters.set('data_point_unit', <any>data_point_unit);
        }
        if (date_utc_min !== undefined && date_utc_min !== null) {
            queryParameters = queryParameters.set('date_utc_min', <any>date_utc_min);
        }
        if (date_utc_max !== undefined && date_utc_max !== null) {
            queryParameters = queryParameters.set('date_utc_max', <any>date_utc_max);
        }
        if (date_utc_offset_base !== undefined && date_utc_offset_base !== null) {
            queryParameters = queryParameters.set('date_utc_offset_base', <any>date_utc_offset_base);
        }
        if (date_offset_sec !== undefined && date_offset_sec !== null) {
            queryParameters = queryParameters.set('date_offset_sec', <any>date_offset_sec);
        }
        if (value_min !== undefined && value_min !== null) {
            queryParameters = queryParameters.set('value_min', <any>value_min);
        }
        if (value_max !== undefined && value_max !== null) {
            queryParameters = queryParameters.set('value_max', <any>value_max);
        }
        if (DataType !== undefined && DataType !== null) {
            queryParameters = queryParameters.set('DataType', <any>DataType);
        }
        if (VirtualInitValue !== undefined && VirtualInitValue !== null) {
            queryParameters = queryParameters.set('VirtualInitValue', <any>VirtualInitValue);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ReportDataQueryOutputDto>>('get',`${this.basePath}/v1/Reports/Filter/data`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Select data via filter options. Returns table with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, RegisterNumber, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  string DevicePointUuid {eq}  string DataType {eq} &#x3D;&gt; possible values are &#x27;json&#x27;(default if not set) and &#x27;csv&#x27;(string) and &#x27;csvfile&#x27;(file object)  string DeviceUuid {eq}  string DeviceTypeName {eq} &#x3D;&gt; e.g. &#x27;Beat-E&#x27;  int RegisterNumber {eq}  string DateUtc {eq,ge,le}  float Value {eq,ge,le}
     * Example  {{base_url}}/reports/filter/data/odata/?$count&#x3D;true&amp;$orderBy&#x3D;dateUtc&amp;$skip&#x3D;5&amp;$top&#x3D;10&amp;$filter&#x3D;RegisterNumber eq 6 and DateUtc ge &#x27;2018-03-04T11:28:18.000000&#x27; and DateUtc le &#x27;2020-03-07T13:29:39.000000&#x27; and DevicePointUuid eq &#x27;dec1ceb01d7aaabea7eaaaaaaaaa0001&#x27; and DeviceUuid eq &#x27;dec1ceaaabea7eaaaaaaaaaaaaaa0001&#x27; and DeviceTypeName eq &#x27;Beat-E&#x27; and Value le 70 and Value ge 2 and DataType eq &#x27;json&#x27;
     * @param device_point_name uuid of the device point which created this data point
     * @param device_point_uuid uuid of the device point which created this data point
     * @param device_uuid name of the device, e.g. \&quot;Wall-E 2\&quot;
     * @param device_type_name type of the device, e.g. \&quot;Wall-E\&quot;
     * @param data_point_id number of the channel, e.g. 6 (6 &#x3D; Temperature_Get, see enum ChannelValueCodes or emico c api)
     * @param data_point_description channel description, e.g. Get Temperature
     * @param data_point_unit channel unit, e.g. DegC
     * @param date_utc_min 
     * @param date_utc_max Consider only datalog elements with date less or equal DateUTCMax
     * @param date_utc_offset_base 
     * @param date_offset_sec Alternative option to set DateUTCMin and DateUTCMax  Only in combination with DateUTC
     * @param value_min Value should be greater equal ValueMin  if we want to allow negatives values, we have to change the generator constaint \&quot;if (valueMin lower 0.0) then\&quot;
     * @param value_max Value should be lower equal ValueMax
     * @param DataType Desired Datatype
     * @param VirtualInitValue should include virtual initial value  if no DataPoint matches filter criteria the last DataPoint befor selected timeframe is given
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataQueryOData(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'body', reportProgress?: boolean): Observable<ODataOutput>;
    public getDataQueryOData(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ODataOutput>>;
    public getDataQueryOData(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ODataOutput>>;
    public getDataQueryOData(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (device_point_name !== undefined && device_point_name !== null) {
            queryParameters = queryParameters.set('device_point_name', <any>device_point_name);
        }
        if (device_point_uuid !== undefined && device_point_uuid !== null) {
            queryParameters = queryParameters.set('device_point_uuid', <any>device_point_uuid);
        }
        if (device_uuid !== undefined && device_uuid !== null) {
            queryParameters = queryParameters.set('device_uuid', <any>device_uuid);
        }
        if (device_type_name !== undefined && device_type_name !== null) {
            queryParameters = queryParameters.set('device_type_name', <any>device_type_name);
        }
        if (data_point_id !== undefined && data_point_id !== null) {
            queryParameters = queryParameters.set('data_point_id', <any>data_point_id);
        }
        if (data_point_description !== undefined && data_point_description !== null) {
            queryParameters = queryParameters.set('data_point_description', <any>data_point_description);
        }
        if (data_point_unit !== undefined && data_point_unit !== null) {
            queryParameters = queryParameters.set('data_point_unit', <any>data_point_unit);
        }
        if (date_utc_min !== undefined && date_utc_min !== null) {
            queryParameters = queryParameters.set('date_utc_min', <any>date_utc_min);
        }
        if (date_utc_max !== undefined && date_utc_max !== null) {
            queryParameters = queryParameters.set('date_utc_max', <any>date_utc_max);
        }
        if (date_utc_offset_base !== undefined && date_utc_offset_base !== null) {
            queryParameters = queryParameters.set('date_utc_offset_base', <any>date_utc_offset_base);
        }
        if (date_offset_sec !== undefined && date_offset_sec !== null) {
            queryParameters = queryParameters.set('date_offset_sec', <any>date_offset_sec);
        }
        if (value_min !== undefined && value_min !== null) {
            queryParameters = queryParameters.set('value_min', <any>value_min);
        }
        if (value_max !== undefined && value_max !== null) {
            queryParameters = queryParameters.set('value_max', <any>value_max);
        }
        if (DataType !== undefined && DataType !== null) {
            queryParameters = queryParameters.set('DataType', <any>DataType);
        }
        if (VirtualInitValue !== undefined && VirtualInitValue !== null) {
            queryParameters = queryParameters.set('VirtualInitValue', <any>VirtualInitValue);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ODataOutput>('get',`${this.basePath}/v1/Reports/Filter/data/odata`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * The top value is ignored in this endpoint  Select data via filter options. Returns a csv file with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, DataPointId, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  string DevicePointUuid {eq}  string DataType {eq} &#x3D;&gt; possible values are &#x27;json&#x27;(default if not set) and &#x27;csv&#x27;(string) and &#x27;csvfile&#x27;(file object)  string DeviceUuid {eq}  string DeviceTypeName {eq} &#x3D;&gt; e.g. &#x27;Beat-E&#x27;  int DataPointId {eq}  string DateUtc {eq,ge,le}  float Value {eq,ge,le}
     * Example  {{base_url}}/reports/filter/data/odata/?$count&#x3D;true&amp;amp;$orderBy&#x3D;dateUtc&amp;amp;$skip&#x3D;5&amp;amp;$top&#x3D;10&amp;amp;$filter&#x3D;DataPointId eq 6 and DateUtc ge &#x27;2018-03-04T11:28:18.000000&#x27; and DateUtc le &#x27;2020-03-07T13:29:39.000000&#x27; and DevicePointUuid eq &#x27;dec1ceb01d7aaabea7eaaaaaaaaa0001&#x27; and DeviceUuid eq &#x27;dec1ceaaabea7eaaaaaaaaaaaaaa0001&#x27; and DeviceTypeName eq &#x27;Beat-E&#x27; and Value le 70 and Value ge 2 and DataType eq &#x27;json&#x27;
     * @param device_point_name uuid of the device point which created this data point
     * @param device_point_uuid uuid of the device point which created this data point
     * @param device_uuid name of the device, e.g. \&quot;Wall-E 2\&quot;
     * @param device_type_name type of the device, e.g. \&quot;Wall-E\&quot;
     * @param data_point_id number of the channel, e.g. 6 (6 &#x3D; Temperature_Get, see enum ChannelValueCodes or emico c api)
     * @param data_point_description channel description, e.g. Get Temperature
     * @param data_point_unit channel unit, e.g. DegC
     * @param date_utc_min 
     * @param date_utc_max Consider only datalog elements with date less or equal DateUTCMax
     * @param date_utc_offset_base 
     * @param date_offset_sec Alternative option to set DateUTCMin and DateUTCMax  Only in combination with DateUTC
     * @param value_min Value should be greater equal ValueMin  if we want to allow negatives values, we have to change the generator constaint \&quot;if (valueMin lower 0.0) then\&quot;
     * @param value_max Value should be lower equal ValueMax
     * @param DataType Desired Datatype
     * @param VirtualInitValue should include virtual initial value  if no DataPoint matches filter criteria the last DataPoint befor selected timeframe is given
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param sid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataQueryODataCsv(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getDataQueryODataCsv(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getDataQueryODataCsv(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getDataQueryODataCsv(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (device_point_name !== undefined && device_point_name !== null) {
            queryParameters = queryParameters.set('device_point_name', <any>device_point_name);
        }
        if (device_point_uuid !== undefined && device_point_uuid !== null) {
            queryParameters = queryParameters.set('device_point_uuid', <any>device_point_uuid);
        }
        if (device_uuid !== undefined && device_uuid !== null) {
            queryParameters = queryParameters.set('device_uuid', <any>device_uuid);
        }
        if (device_type_name !== undefined && device_type_name !== null) {
            queryParameters = queryParameters.set('device_type_name', <any>device_type_name);
        }
        if (data_point_id !== undefined && data_point_id !== null) {
            queryParameters = queryParameters.set('data_point_id', <any>data_point_id);
        }
        if (data_point_description !== undefined && data_point_description !== null) {
            queryParameters = queryParameters.set('data_point_description', <any>data_point_description);
        }
        if (data_point_unit !== undefined && data_point_unit !== null) {
            queryParameters = queryParameters.set('data_point_unit', <any>data_point_unit);
        }
        if (date_utc_min !== undefined && date_utc_min !== null) {
            queryParameters = queryParameters.set('date_utc_min', <any>date_utc_min);
        }
        if (date_utc_max !== undefined && date_utc_max !== null) {
            queryParameters = queryParameters.set('date_utc_max', <any>date_utc_max);
        }
        if (date_utc_offset_base !== undefined && date_utc_offset_base !== null) {
            queryParameters = queryParameters.set('date_utc_offset_base', <any>date_utc_offset_base);
        }
        if (date_offset_sec !== undefined && date_offset_sec !== null) {
            queryParameters = queryParameters.set('date_offset_sec', <any>date_offset_sec);
        }
        if (value_min !== undefined && value_min !== null) {
            queryParameters = queryParameters.set('value_min', <any>value_min);
        }
        if (value_max !== undefined && value_max !== null) {
            queryParameters = queryParameters.set('value_max', <any>value_max);
        }
        if (DataType !== undefined && DataType !== null) {
            queryParameters = queryParameters.set('DataType', <any>DataType);
        }
        if (VirtualInitValue !== undefined && VirtualInitValue !== null) {
            queryParameters = queryParameters.set('VirtualInitValue', <any>VirtualInitValue);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }
        if (sid !== undefined && sid !== null) {
            queryParameters = queryParameters.set('sid', <any>sid);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<string>('get',`${this.basePath}/v1/Reports/Filter/data/odatacsv`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * The top value is ignored in this endpoint  Select data via filter options. Returns a csv file with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, DataPointId, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  string DevicePointUuid {eq}  string DeviceUuid {eq}  string DeviceTypeName {eq} &#x3D;&gt; e.g. &#x27;Beat-E&#x27;  int DataPointId {eq}  string DateUtc {eq,ge,le}  float Value {eq,ge,le}
     * Example  {{base_url}}/reports/filter/data/odata/?$count&#x3D;true&amp;$orderBy&#x3D;dateUtc&amp;$skip&#x3D;5&amp;$top&#x3D;10&amp;$filter&#x3D;DataPointId eq 6 and DateUtc ge &#x27;2018-03-04T11:28:18.000000&#x27; and DateUtc le &#x27;2020-03-07T13:29:39.000000&#x27; and DevicePointUuid eq &#x27;dec1ceb01d7aaabea7eaaaaaaaaa0001&#x27; and DeviceUuid eq &#x27;dec1ceaaabea7eaaaaaaaaaaaaaa0001&#x27; and DeviceTypeName eq &#x27;Beat-E&#x27; and Value le 70 and Value ge 2 and DataType eq &#x27;json&#x27;
     * @param device_point_name uuid of the device point which created this data point
     * @param device_point_uuid uuid of the device point which created this data point
     * @param device_uuid name of the device, e.g. \&quot;Wall-E 2\&quot;
     * @param device_type_name type of the device, e.g. \&quot;Wall-E\&quot;
     * @param data_point_id number of the channel, e.g. 6 (6 &#x3D; Temperature_Get, see enum ChannelValueCodes or emico c api)
     * @param data_point_description channel description, e.g. Get Temperature
     * @param data_point_unit channel unit, e.g. DegC
     * @param date_utc_min 
     * @param date_utc_max Consider only datalog elements with date less or equal DateUTCMax
     * @param date_utc_offset_base 
     * @param date_offset_sec Alternative option to set DateUTCMin and DateUTCMax  Only in combination with DateUTC
     * @param value_min Value should be greater equal ValueMin  if we want to allow negatives values, we have to change the generator constaint \&quot;if (valueMin lower 0.0) then\&quot;
     * @param value_max Value should be lower equal ValueMax
     * @param DataType Desired Datatype
     * @param VirtualInitValue should include virtual initial value  if no DataPoint matches filter criteria the last DataPoint befor selected timeframe is given
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param sid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataQueryODataPdf(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getDataQueryODataPdf(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getDataQueryODataPdf(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getDataQueryODataPdf(device_point_name?: string, device_point_uuid?: string, device_uuid?: string, device_type_name?: string, data_point_id?: number, data_point_description?: string, data_point_unit?: string, date_utc_min?: string, date_utc_max?: string, date_utc_offset_base?: string, date_offset_sec?: number, value_min?: number, value_max?: number, DataType?: OutputDataType, VirtualInitValue?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (device_point_name !== undefined && device_point_name !== null) {
            queryParameters = queryParameters.set('device_point_name', <any>device_point_name);
        }
        if (device_point_uuid !== undefined && device_point_uuid !== null) {
            queryParameters = queryParameters.set('device_point_uuid', <any>device_point_uuid);
        }
        if (device_uuid !== undefined && device_uuid !== null) {
            queryParameters = queryParameters.set('device_uuid', <any>device_uuid);
        }
        if (device_type_name !== undefined && device_type_name !== null) {
            queryParameters = queryParameters.set('device_type_name', <any>device_type_name);
        }
        if (data_point_id !== undefined && data_point_id !== null) {
            queryParameters = queryParameters.set('data_point_id', <any>data_point_id);
        }
        if (data_point_description !== undefined && data_point_description !== null) {
            queryParameters = queryParameters.set('data_point_description', <any>data_point_description);
        }
        if (data_point_unit !== undefined && data_point_unit !== null) {
            queryParameters = queryParameters.set('data_point_unit', <any>data_point_unit);
        }
        if (date_utc_min !== undefined && date_utc_min !== null) {
            queryParameters = queryParameters.set('date_utc_min', <any>date_utc_min);
        }
        if (date_utc_max !== undefined && date_utc_max !== null) {
            queryParameters = queryParameters.set('date_utc_max', <any>date_utc_max);
        }
        if (date_utc_offset_base !== undefined && date_utc_offset_base !== null) {
            queryParameters = queryParameters.set('date_utc_offset_base', <any>date_utc_offset_base);
        }
        if (date_offset_sec !== undefined && date_offset_sec !== null) {
            queryParameters = queryParameters.set('date_offset_sec', <any>date_offset_sec);
        }
        if (value_min !== undefined && value_min !== null) {
            queryParameters = queryParameters.set('value_min', <any>value_min);
        }
        if (value_max !== undefined && value_max !== null) {
            queryParameters = queryParameters.set('value_max', <any>value_max);
        }
        if (DataType !== undefined && DataType !== null) {
            queryParameters = queryParameters.set('DataType', <any>DataType);
        }
        if (VirtualInitValue !== undefined && VirtualInitValue !== null) {
            queryParameters = queryParameters.set('VirtualInitValue', <any>VirtualInitValue);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }
        if (sid !== undefined && sid !== null) {
            queryParameters = queryParameters.set('sid', <any>sid);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<string>('get',`${this.basePath}/v1/Reports/Filter/data/odatapdf`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param devicePointUUID 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLastFlushingTimestamp(devicePointUUID?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getLastFlushingTimestamp(devicePointUUID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getLastFlushingTimestamp(devicePointUUID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getLastFlushingTimestamp(devicePointUUID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (devicePointUUID !== undefined && devicePointUUID !== null) {
            queryParameters = queryParameters.set('devicePointUUID', <any>devicePointUUID);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<string>('get',`${this.basePath}/v1/Reports/Filter/lastflush`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Used for dropdown filtering (e.g. select typeName \&quot;Wall-E\&quot; &#x3D;&gt; get all devicePointNames/uuid&#x27;s with Type \&quot;Wall-E\&quot;).   Returns table with columns uuid, devicePointName, typeName, channelName
     * Example  &lt;pre&gt;  {   \&quot;uuid\&quot;:\&quot;8953641b732467a4d07372d45eb05abc\&quot;,   \&quot;devicePointName\&quot;:\&quot;Wandauslauf 12\&quot;,   \&quot;typeName\&quot;:\&quot;DTE\&quot;,   \&quot;channelChannelNo\&quot;:\&quot;4\&quot;,   \&quot;channelName\&quot;:\&quot;Mischtemp.\&quot;  }  &lt;/pre&gt;
     * @param device_point_uuid name of the device point, e.g. \&quot;Wandauslauf Zimmer 1\&quot;
     * @param device_uuid name of the device, e.g. \&quot;Wall-E 2\&quot;
     * @param device_type_name type of the device, e.g. \&quot;Wall-E\&quot;
     * @param unit unit of DataPoint, e.g. \&quot;degC\&quot;
     * @param data_point_id number of the channel, e.g. 6 (6 &#x3D; Temperature_Get, see enum ChannelValueCodes or emico c api)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOptionQuery(device_point_uuid?: string, device_uuid?: string, device_type_name?: string, unit?: string, data_point_id?: number, observe?: 'body', reportProgress?: boolean): Observable<ReportOptionsQueryResultDto>;
    public getOptionQuery(device_point_uuid?: string, device_uuid?: string, device_type_name?: string, unit?: string, data_point_id?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReportOptionsQueryResultDto>>;
    public getOptionQuery(device_point_uuid?: string, device_uuid?: string, device_type_name?: string, unit?: string, data_point_id?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReportOptionsQueryResultDto>>;
    public getOptionQuery(device_point_uuid?: string, device_uuid?: string, device_type_name?: string, unit?: string, data_point_id?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (device_point_uuid !== undefined && device_point_uuid !== null) {
            queryParameters = queryParameters.set('device_point_uuid', <any>device_point_uuid);
        }
        if (device_uuid !== undefined && device_uuid !== null) {
            queryParameters = queryParameters.set('device_uuid', <any>device_uuid);
        }
        if (device_type_name !== undefined && device_type_name !== null) {
            queryParameters = queryParameters.set('device_type_name', <any>device_type_name);
        }
        if (unit !== undefined && unit !== null) {
            queryParameters = queryParameters.set('unit', <any>unit);
        }
        if (data_point_id !== undefined && data_point_id !== null) {
            queryParameters = queryParameters.set('data_point_id', <any>data_point_id);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ReportOptionsQueryResultDto>('get',`${this.basePath}/v1/Reports/Filter/option`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all possible values per filter category (e.g. all device names)
     * 
     * @param filterCategory filter category
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOptions(filterCategory: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getOptions(filterCategory: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getOptions(filterCategory: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getOptions(filterCategory: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (filterCategory === null || filterCategory === undefined) {
            throw new Error('Required parameter filterCategory was null or undefined when calling getOptions.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/v1/Reports/Filter/options/${encodeURIComponent(String(filterCategory))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    public getOdataEndPoint(): string { return `${this.basePath}/v1/Reports/Filter/data/odata`; }
}
