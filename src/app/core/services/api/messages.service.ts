/**
 * TWMS REST API
 * TWMS REST API
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { EventTypes } from '../model/eventTypes';
import { FileStreamObject } from '../model/fileStreamObject';
import { ForbiddenResponse } from '../model/forbiddenResponse';
import { MessageEditInput } from '../model/messageEditInput';
import { MessageIdsInput } from '../model/messageIdsInput';
import { MessageOutputDto } from '../model/messageOutputDto';
import { ODataOutput } from '../model/oDataOutput';
import { UnauthorizedResponse } from '../model/unauthorizedResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class MessagesService {

    protected basePath = '/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes all messages of the specified index. A message should only be completely erasable from the system if it has previously been marked as deleted. For this purpose, the attribute &#x27;DeletedTimestamp&#x27; of the entity &#x27;msg_messageLog&#x27; must have an arbitrary date. This should only represent a ToDo flag according to the specifications. The actual size of the database on the disk did not change after the execution!
     * 
     * @param rowId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMessagesIds(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteMessagesIds(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteMessagesIds(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteMessagesIds(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling deleteMessagesIds.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/v1/Messages/delete/fromdisk/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edits message Information not implemented
     * Example  &lt;pre&gt;  {   \&quot;description\&quot;:\&quot;new description\&quot;,   \&quot;summary\&quot;: \&quot;new summary\&quot;,  }  &lt;/pre&gt;
     * @param rowId 
     * @param body edit message input object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editMessage(rowId: number, body?: MessageEditInput, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public editMessage(rowId: number, body?: MessageEditInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public editMessage(rowId: number, body?: MessageEditInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public editMessage(rowId: number, body?: MessageEditInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling editMessage.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/edit/${encodeURIComponent(String(rowId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Message list
     * 
     * @param body message type e.g. &quot;ALRAM&quot; or &quot;DISRUPTION&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllMessages(body?: Array<EventTypes>, observe?: 'body', reportProgress?: boolean): Observable<Array<MessageOutputDto>>;
    public getAllMessages(body?: Array<EventTypes>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MessageOutputDto>>>;
    public getAllMessages(body?: Array<EventTypes>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageOutputDto>>>;
    public getAllMessages(body?: Array<EventTypes>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<MessageOutputDto>>('post',`${this.basePath}/v1/Messages/list`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get messages filtered by the given parameters
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataMaxRowId(observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getDataMaxRowId(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getDataMaxRowId(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getDataMaxRowId(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<number>('get',`${this.basePath}/v1/Messages/messagesmaxrow`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get DataLog max row id
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDatalogMaxRowId(observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getDatalogMaxRowId(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getDatalogMaxRowId(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getDatalogMaxRowId(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<number>('get',`${this.basePath}/v1/Messages/datalogmaxrow`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get error messages as list
     * 
     * @param uuid uuid of device to get error list from
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getErrorMessages(uuid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MessageOutputDto>>;
    public getErrorMessages(uuid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MessageOutputDto>>>;
    public getErrorMessages(uuid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageOutputDto>>>;
    public getErrorMessages(uuid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getErrorMessages.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<MessageOutputDto>>('get',`${this.basePath}/v1/Messages/errorlist/${encodeURIComponent(String(uuid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get historical Message list
     * 
     * @param body message type e.g. &quot;ALRAM&quot; or &quot;DISRUPTION&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHistoricalMessages(body?: Array<EventTypes>, observe?: 'body', reportProgress?: boolean): Observable<Array<MessageOutputDto>>;
    public getHistoricalMessages(body?: Array<EventTypes>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MessageOutputDto>>>;
    public getHistoricalMessages(body?: Array<EventTypes>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageOutputDto>>>;
    public getHistoricalMessages(body?: Array<EventTypes>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<MessageOutputDto>>('post',`${this.basePath}/v1/Messages/history`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get detail information for messages
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessage(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<MessageOutputDto>;
    public getMessage(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MessageOutputDto>>;
    public getMessage(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessageOutputDto>>;
    public getMessage(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling getMessage.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<MessageOutputDto>('get',`${this.basePath}/v1/Messages/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get detail information for messages
     * 
     * @param body message id&#x27;s
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessages(body?: MessageIdsInput, observe?: 'body', reportProgress?: boolean): Observable<Array<MessageOutputDto>>;
    public getMessages(body?: MessageIdsInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MessageOutputDto>>>;
    public getMessages(body?: MessageIdsInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageOutputDto>>>;
    public getMessages(body?: MessageIdsInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<MessageOutputDto>>('get',`${this.basePath}/v1/Messages`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Select data via filter options. Returns table with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, RegisterNumber, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  int ErrorCode {eq}  string SortDirection {eq} &#x3D;&gt; possible values are &#x27;DESC&#x27;(default if not set) and &#x27;ASC&#x27;   string CreatedByUuid {eq}  string ViewedByUuid {eq}  string AcknowledgedByUuid {eq}  string FixedByUuid {eq}  string CreatedTime {eq,ge,le}  string ViewedTime {eq,ge,le}  string AcknowledgedTime {eq,ge,le}  string FixedTime {eq,ge,le}  EventTypes is a custom parameter (see example below), e.g. &#x27;ALARM&#x27; or &#x27;DISRUPTION&#x27; or &#x27;ALARM|DISRUPTION&#x27;
     * Example  {{base_url}}/messages/odata?$count&#x3D;true&amp;amp;EventTypes&#x3D;ALARM|DISRUPTIONamp;amp;$orderBy&#x3D;CreatedTime&amp;amp;$skip&#x3D;0&amp;amp;$top&#x3D;20&amp;amp;$filter&#x3D;ErrorCode eq 0 and CreatedByUuid eq &amp;apos;dec1ceb01d7aaabea7eaaaaaaaaa0001&amp;apos; and CreatedTime ge &amp;apos;2018-03-04T11:28:18.000000&amp;apos; and CreatedTime le &amp;apos;2020-03-04T13:29:39.000000&amp;apos; and ViewedByUuid eq &amp;apos;683963e2-f976-4075-53b6-f942f128&amp;apos; and ViewedTime ge &amp;apos;2018-03-04T11:28:18.000000&amp;apos; and ViewedTime le &amp;apos;2020-03-04T13:29:39.000000&amp;apos; and AcknowledgedByUuid eq &amp;apos;683963e2-f976-4075-53b6-f942f128&amp;apos; and AcknowledgedTime ge &amp;apos;2018-03-04T11:28:18.000000&amp;apos; and AcknowledgedTime le &amp;apos;2020-03-04T13:29:39.000000&amp;apos; and FixedByUuid eq &amp;apos;683963e2-f976-4075-53b6-f942f128&amp;apos; and FixedTime ge &amp;apos;2018-03-04T11:28:18.000000&amp;apos; and FixedTime le &amp;apos;2020-03-04T13:29:39.000000&amp;apos; and SortDirection eq &amp;apos;ASC&amp;apos;
     * @param ErrorCodeMin unique error code
     * @param ErrorCodeMax 
     * @param MessagesMaxRowId Messages Max Row ID
     * @param EventTypes e.g. ALARM, EVENT
     * @param CreatedTimeMin timestamp message occured
     * @param CreatedTimeMax timestamp message occured
     * @param CreatedByUuid_Value 
     * @param CreatedByUuid_NotEqual 
     * @param DeviceUuid_Value 
     * @param DeviceUuid_NotEqual 
     * @param DeviceTypeName_Value 
     * @param DeviceTypeName_NotEqual 
     * @param ViewedTimeMin timestamp when the user accessed the message for the first time
     * @param ViewedTimeMax timestamp when the user accessed the message for the first time
     * @param ViewedByUuid_Value 
     * @param ViewedByUuid_NotEqual 
     * @param ViewedIsNull true &#x3D; return messages with ViewedTimestamp &#x3D;&#x3D; NULL
     * @param AcknowledgedTimeMin timestamp of user acknowledgement
     * @param AcknowledgedTimeMax timestamp of user acknowledgement
     * @param AcknowledgedByUuid_Value 
     * @param AcknowledgedByUuid_NotEqual 
     * @param AcknowledgedIsNull true &#x3D; return messages with AcknowledgedTimestamp &#x3D;&#x3D; NULL
     * @param FixedTimeMin timestamp of user resolve fix
     * @param FixedTimeMax timestamp of user resolve fix
     * @param FixedByUuid_Value 
     * @param FixedByUuid_NotEqual 
     * @param FixedIsNull true &#x3D; return messages with FixedTimestamp &#x3D;&#x3D; NULL
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessagesOData(ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'body', reportProgress?: boolean): Observable<ODataOutput>;
    public getMessagesOData(ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ODataOutput>>;
    public getMessagesOData(ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ODataOutput>>;
    public getMessagesOData(ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ErrorCodeMin !== undefined && ErrorCodeMin !== null) {
            queryParameters = queryParameters.set('ErrorCodeMin', <any>ErrorCodeMin);
        }
        if (ErrorCodeMax !== undefined && ErrorCodeMax !== null) {
            queryParameters = queryParameters.set('ErrorCodeMax', <any>ErrorCodeMax);
        }
        if (MessagesMaxRowId !== undefined && MessagesMaxRowId !== null) {
            queryParameters = queryParameters.set('MessagesMaxRowId', <any>MessagesMaxRowId);
        }
        if (EventTypes) {
            EventTypes.forEach((element) => {
                queryParameters = queryParameters.append('EventTypes', <any>element);
            })
        }
        if (CreatedTimeMin !== undefined && CreatedTimeMin !== null) {
            queryParameters = queryParameters.set('CreatedTimeMin', <any>CreatedTimeMin);
        }
        if (CreatedTimeMax !== undefined && CreatedTimeMax !== null) {
            queryParameters = queryParameters.set('CreatedTimeMax', <any>CreatedTimeMax);
        }
        if (CreatedByUuid_Value !== undefined && CreatedByUuid_Value !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.Value', <any>CreatedByUuid_Value);
        }
        if (CreatedByUuid_NotEqual !== undefined && CreatedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.NotEqual', <any>CreatedByUuid_NotEqual);
        }
        if (DeviceUuid_Value !== undefined && DeviceUuid_Value !== null) {
            queryParameters = queryParameters.set('DeviceUuid.Value', <any>DeviceUuid_Value);
        }
        if (DeviceUuid_NotEqual !== undefined && DeviceUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceUuid.NotEqual', <any>DeviceUuid_NotEqual);
        }
        if (DeviceTypeName_Value !== undefined && DeviceTypeName_Value !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.Value', <any>DeviceTypeName_Value);
        }
        if (DeviceTypeName_NotEqual !== undefined && DeviceTypeName_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.NotEqual', <any>DeviceTypeName_NotEqual);
        }
        if (ViewedTimeMin !== undefined && ViewedTimeMin !== null) {
            queryParameters = queryParameters.set('ViewedTimeMin', <any>ViewedTimeMin);
        }
        if (ViewedTimeMax !== undefined && ViewedTimeMax !== null) {
            queryParameters = queryParameters.set('ViewedTimeMax', <any>ViewedTimeMax);
        }
        if (ViewedByUuid_Value !== undefined && ViewedByUuid_Value !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.Value', <any>ViewedByUuid_Value);
        }
        if (ViewedByUuid_NotEqual !== undefined && ViewedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.NotEqual', <any>ViewedByUuid_NotEqual);
        }
        if (ViewedIsNull !== undefined && ViewedIsNull !== null) {
            queryParameters = queryParameters.set('ViewedIsNull', <any>ViewedIsNull);
        }
        if (AcknowledgedTimeMin !== undefined && AcknowledgedTimeMin !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMin', <any>AcknowledgedTimeMin);
        }
        if (AcknowledgedTimeMax !== undefined && AcknowledgedTimeMax !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMax', <any>AcknowledgedTimeMax);
        }
        if (AcknowledgedByUuid_Value !== undefined && AcknowledgedByUuid_Value !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.Value', <any>AcknowledgedByUuid_Value);
        }
        if (AcknowledgedByUuid_NotEqual !== undefined && AcknowledgedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.NotEqual', <any>AcknowledgedByUuid_NotEqual);
        }
        if (AcknowledgedIsNull !== undefined && AcknowledgedIsNull !== null) {
            queryParameters = queryParameters.set('AcknowledgedIsNull', <any>AcknowledgedIsNull);
        }
        if (FixedTimeMin !== undefined && FixedTimeMin !== null) {
            queryParameters = queryParameters.set('FixedTimeMin', <any>FixedTimeMin);
        }
        if (FixedTimeMax !== undefined && FixedTimeMax !== null) {
            queryParameters = queryParameters.set('FixedTimeMax', <any>FixedTimeMax);
        }
        if (FixedByUuid_Value !== undefined && FixedByUuid_Value !== null) {
            queryParameters = queryParameters.set('FixedByUuid.Value', <any>FixedByUuid_Value);
        }
        if (FixedByUuid_NotEqual !== undefined && FixedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('FixedByUuid.NotEqual', <any>FixedByUuid_NotEqual);
        }
        if (FixedIsNull !== undefined && FixedIsNull !== null) {
            queryParameters = queryParameters.set('FixedIsNull', <any>FixedIsNull);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ODataOutput>('get',`${this.basePath}/v1/Messages/odata`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Select data via filter options. Returns a csv file with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, DataPointId, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  int ErrorCode {eq}  string SortDirection {eq} &#x3D;&gt; possible values are &#x27;DESC&#x27;(default if not set) and &#x27;ASC&#x27;   string EventType {eq} &#x3D;&gt; e.g. &#x27;ALARM&#x27; or &#x27;DISRUPTION&#x27;  string CreatedByUuid {eq}  string ViewedByUuid {eq}  string AcknowledgedByUuid {eq}  string FixedByUuid {eq}  string CreatedTime {eq,ge,le}  string ViewedTime {eq,ge,le}  string AcknowledgedTime {eq,ge,le}  string FixedTime {eq,ge,le}
     * Example  {{base_url}}/messages/odata?$count&#x3D;true&amp;$orderBy&#x3D;CreatedTime&amp;$skip&#x3D;0&amp;$top&#x3D;20&amp;$filter&#x3D;ErrorCode eq 0 and EventType eq &#x27;ALARM&#x27; and CreatedByUuid eq &#x27;dec1ceb01d7aaabea7eaaaaaaaaa0001&#x27; and CreatedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and CreatedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and ViewedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and ViewedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and ViewedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and AcknowledgedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and AcknowledgedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and AcknowledgedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and FixedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and FixedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and FixedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and SortDirection eq &#x27;ASC&#x27;
     * @param exportFileName File name of the returned file
     * @param ErrorCodeMin unique error code
     * @param ErrorCodeMax 
     * @param MessagesMaxRowId Messages Max Row ID
     * @param EventTypes e.g. ALARM, EVENT
     * @param CreatedTimeMin timestamp message occured
     * @param CreatedTimeMax timestamp message occured
     * @param CreatedByUuid_Value 
     * @param CreatedByUuid_NotEqual 
     * @param DeviceUuid_Value 
     * @param DeviceUuid_NotEqual 
     * @param DeviceTypeName_Value 
     * @param DeviceTypeName_NotEqual 
     * @param ViewedTimeMin timestamp when the user accessed the message for the first time
     * @param ViewedTimeMax timestamp when the user accessed the message for the first time
     * @param ViewedByUuid_Value 
     * @param ViewedByUuid_NotEqual 
     * @param ViewedIsNull true &#x3D; return messages with ViewedTimestamp &#x3D;&#x3D; NULL
     * @param AcknowledgedTimeMin timestamp of user acknowledgement
     * @param AcknowledgedTimeMax timestamp of user acknowledgement
     * @param AcknowledgedByUuid_Value 
     * @param AcknowledgedByUuid_NotEqual 
     * @param AcknowledgedIsNull true &#x3D; return messages with AcknowledgedTimestamp &#x3D;&#x3D; NULL
     * @param FixedTimeMin timestamp of user resolve fix
     * @param FixedTimeMax timestamp of user resolve fix
     * @param FixedByUuid_Value 
     * @param FixedByUuid_NotEqual 
     * @param FixedIsNull true &#x3D; return messages with FixedTimestamp &#x3D;&#x3D; NULL
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param sid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessagesODataCsv(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'body', reportProgress?: boolean): Observable<FileStreamObject>;
    public getMessagesODataCsv(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileStreamObject>>;
    public getMessagesODataCsv(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileStreamObject>>;
    public getMessagesODataCsv(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (exportFileName === null || exportFileName === undefined) {
            throw new Error('Required parameter exportFileName was null or undefined when calling getMessagesODataCsv.');
        }


































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ErrorCodeMin !== undefined && ErrorCodeMin !== null) {
            queryParameters = queryParameters.set('ErrorCodeMin', <any>ErrorCodeMin);
        }
        if (ErrorCodeMax !== undefined && ErrorCodeMax !== null) {
            queryParameters = queryParameters.set('ErrorCodeMax', <any>ErrorCodeMax);
        }
        if (MessagesMaxRowId !== undefined && MessagesMaxRowId !== null) {
            queryParameters = queryParameters.set('MessagesMaxRowId', <any>MessagesMaxRowId);
        }
        if (EventTypes) {
            EventTypes.forEach((element) => {
                queryParameters = queryParameters.append('EventTypes', <any>element);
            })
        }
        if (CreatedTimeMin !== undefined && CreatedTimeMin !== null) {
            queryParameters = queryParameters.set('CreatedTimeMin', <any>CreatedTimeMin);
        }
        if (CreatedTimeMax !== undefined && CreatedTimeMax !== null) {
            queryParameters = queryParameters.set('CreatedTimeMax', <any>CreatedTimeMax);
        }
        if (CreatedByUuid_Value !== undefined && CreatedByUuid_Value !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.Value', <any>CreatedByUuid_Value);
        }
        if (CreatedByUuid_NotEqual !== undefined && CreatedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.NotEqual', <any>CreatedByUuid_NotEqual);
        }
        if (DeviceUuid_Value !== undefined && DeviceUuid_Value !== null) {
            queryParameters = queryParameters.set('DeviceUuid.Value', <any>DeviceUuid_Value);
        }
        if (DeviceUuid_NotEqual !== undefined && DeviceUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceUuid.NotEqual', <any>DeviceUuid_NotEqual);
        }
        if (DeviceTypeName_Value !== undefined && DeviceTypeName_Value !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.Value', <any>DeviceTypeName_Value);
        }
        if (DeviceTypeName_NotEqual !== undefined && DeviceTypeName_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.NotEqual', <any>DeviceTypeName_NotEqual);
        }
        if (ViewedTimeMin !== undefined && ViewedTimeMin !== null) {
            queryParameters = queryParameters.set('ViewedTimeMin', <any>ViewedTimeMin);
        }
        if (ViewedTimeMax !== undefined && ViewedTimeMax !== null) {
            queryParameters = queryParameters.set('ViewedTimeMax', <any>ViewedTimeMax);
        }
        if (ViewedByUuid_Value !== undefined && ViewedByUuid_Value !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.Value', <any>ViewedByUuid_Value);
        }
        if (ViewedByUuid_NotEqual !== undefined && ViewedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.NotEqual', <any>ViewedByUuid_NotEqual);
        }
        if (ViewedIsNull !== undefined && ViewedIsNull !== null) {
            queryParameters = queryParameters.set('ViewedIsNull', <any>ViewedIsNull);
        }
        if (AcknowledgedTimeMin !== undefined && AcknowledgedTimeMin !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMin', <any>AcknowledgedTimeMin);
        }
        if (AcknowledgedTimeMax !== undefined && AcknowledgedTimeMax !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMax', <any>AcknowledgedTimeMax);
        }
        if (AcknowledgedByUuid_Value !== undefined && AcknowledgedByUuid_Value !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.Value', <any>AcknowledgedByUuid_Value);
        }
        if (AcknowledgedByUuid_NotEqual !== undefined && AcknowledgedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.NotEqual', <any>AcknowledgedByUuid_NotEqual);
        }
        if (AcknowledgedIsNull !== undefined && AcknowledgedIsNull !== null) {
            queryParameters = queryParameters.set('AcknowledgedIsNull', <any>AcknowledgedIsNull);
        }
        if (FixedTimeMin !== undefined && FixedTimeMin !== null) {
            queryParameters = queryParameters.set('FixedTimeMin', <any>FixedTimeMin);
        }
        if (FixedTimeMax !== undefined && FixedTimeMax !== null) {
            queryParameters = queryParameters.set('FixedTimeMax', <any>FixedTimeMax);
        }
        if (FixedByUuid_Value !== undefined && FixedByUuid_Value !== null) {
            queryParameters = queryParameters.set('FixedByUuid.Value', <any>FixedByUuid_Value);
        }
        if (FixedByUuid_NotEqual !== undefined && FixedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('FixedByUuid.NotEqual', <any>FixedByUuid_NotEqual);
        }
        if (FixedIsNull !== undefined && FixedIsNull !== null) {
            queryParameters = queryParameters.set('FixedIsNull', <any>FixedIsNull);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }
        if (sid !== undefined && sid !== null) {
            queryParameters = queryParameters.set('sid', <any>sid);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileStreamObject>('get',`${this.basePath}/v1/Messages/odatacsv`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Select data via filter options. Returns a csv file with columns DateUtc, DevicePointName, DevicePointUuid, DeviceName, DeviceUuid, DeviceTypeName, DataPointId, Value  You can set the following filter parameters {this predicates are possible for the parameter}:  int ErrorCode {eq}  string SortDirection {eq} &#x3D;&gt; possible values are &#x27;DESC&#x27;(default if not set) and &#x27;ASC&#x27;   string EventType {eq} &#x3D;&gt; e.g. &#x27;ALARM&#x27; or &#x27;DISRUPTION&#x27;  string CreatedByUuid {eq}  string ViewedByUuid {eq}  string AcknowledgedByUuid {eq}  string FixedByUuid {eq}  string CreatedTime {eq,ge,le}  string ViewedTime {eq,ge,le}  string AcknowledgedTime {eq,ge,le}  string FixedTime {eq,ge,le}
     * Example  {{base_url}}/messages/odata?$count&#x3D;true&amp;$orderBy&#x3D;CreatedTime&amp;$skip&#x3D;0&amp;$top&#x3D;20&amp;$filter&#x3D;ErrorCode eq 0 and EventType eq &#x27;ALARM&#x27; and CreatedByUuid eq &#x27;dec1ceb01d7aaabea7eaaaaaaaaa0001&#x27; and CreatedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and CreatedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and ViewedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and ViewedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and ViewedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and AcknowledgedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and AcknowledgedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and AcknowledgedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and FixedByUuid eq &#x27;683963e2-f976-4075-53b6-f942f128&#x27; and FixedTime ge &#x27;2018-03-04T11:28:18.000000&#x27; and FixedTime le &#x27;2020-03-04T13:29:39.000000&#x27; and SortDirection eq &#x27;ASC&#x27;
     * @param exportFileName File name of the returned file
     * @param ErrorCodeMin unique error code
     * @param ErrorCodeMax 
     * @param MessagesMaxRowId Messages Max Row ID
     * @param EventTypes e.g. ALARM, EVENT
     * @param CreatedTimeMin timestamp message occured
     * @param CreatedTimeMax timestamp message occured
     * @param CreatedByUuid_Value 
     * @param CreatedByUuid_NotEqual 
     * @param DeviceUuid_Value 
     * @param DeviceUuid_NotEqual 
     * @param DeviceTypeName_Value 
     * @param DeviceTypeName_NotEqual 
     * @param ViewedTimeMin timestamp when the user accessed the message for the first time
     * @param ViewedTimeMax timestamp when the user accessed the message for the first time
     * @param ViewedByUuid_Value 
     * @param ViewedByUuid_NotEqual 
     * @param ViewedIsNull true &#x3D; return messages with ViewedTimestamp &#x3D;&#x3D; NULL
     * @param AcknowledgedTimeMin timestamp of user acknowledgement
     * @param AcknowledgedTimeMax timestamp of user acknowledgement
     * @param AcknowledgedByUuid_Value 
     * @param AcknowledgedByUuid_NotEqual 
     * @param AcknowledgedIsNull true &#x3D; return messages with AcknowledgedTimestamp &#x3D;&#x3D; NULL
     * @param FixedTimeMin timestamp of user resolve fix
     * @param FixedTimeMax timestamp of user resolve fix
     * @param FixedByUuid_Value 
     * @param FixedByUuid_NotEqual 
     * @param FixedIsNull true &#x3D; return messages with FixedTimestamp &#x3D;&#x3D; NULL
     * @param limit Limits the number of returned data log entries (obtained by the query)
     * @param Offset Offset for the query result (useful for pagination)
     * @param skiptoken Predicate for the seek pagination (row id)
     * @param order_by Order the returned data log entries (by now there is only the \&quot;Date\&quot; column supported)
     * @param order Order of the returned data log entries (dependent to OrderBy)  \&quot;asc\&quot; or \&quot;desc\&quot; allowed, default OrderBy column is \&quot;date\&quot;
     * @param sid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessagesODataCsv_1(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'body', reportProgress?: boolean): Observable<FileStreamObject>;
    public getMessagesODataCsv_1(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileStreamObject>>;
    public getMessagesODataCsv_1(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileStreamObject>>;
    public getMessagesODataCsv_1(exportFileName: string, ErrorCodeMin?: number, ErrorCodeMax?: number, MessagesMaxRowId?: number, EventTypes?: Array<string>, CreatedTimeMin?: string, CreatedTimeMax?: string, CreatedByUuid_Value?: string, CreatedByUuid_NotEqual?: boolean, DeviceUuid_Value?: string, DeviceUuid_NotEqual?: boolean, DeviceTypeName_Value?: string, DeviceTypeName_NotEqual?: boolean, ViewedTimeMin?: string, ViewedTimeMax?: string, ViewedByUuid_Value?: string, ViewedByUuid_NotEqual?: boolean, ViewedIsNull?: boolean, AcknowledgedTimeMin?: string, AcknowledgedTimeMax?: string, AcknowledgedByUuid_Value?: string, AcknowledgedByUuid_NotEqual?: boolean, AcknowledgedIsNull?: boolean, FixedTimeMin?: string, FixedTimeMax?: string, FixedByUuid_Value?: string, FixedByUuid_NotEqual?: boolean, FixedIsNull?: boolean, limit?: number, Offset?: number, skiptoken?: number, order_by?: string, order?: string, sid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (exportFileName === null || exportFileName === undefined) {
            throw new Error('Required parameter exportFileName was null or undefined when calling getMessagesODataCsv_1.');
        }


































        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ErrorCodeMin !== undefined && ErrorCodeMin !== null) {
            queryParameters = queryParameters.set('ErrorCodeMin', <any>ErrorCodeMin);
        }
        if (ErrorCodeMax !== undefined && ErrorCodeMax !== null) {
            queryParameters = queryParameters.set('ErrorCodeMax', <any>ErrorCodeMax);
        }
        if (MessagesMaxRowId !== undefined && MessagesMaxRowId !== null) {
            queryParameters = queryParameters.set('MessagesMaxRowId', <any>MessagesMaxRowId);
        }
        if (EventTypes) {
            EventTypes.forEach((element) => {
                queryParameters = queryParameters.append('EventTypes', <any>element);
            })
        }
        if (CreatedTimeMin !== undefined && CreatedTimeMin !== null) {
            queryParameters = queryParameters.set('CreatedTimeMin', <any>CreatedTimeMin);
        }
        if (CreatedTimeMax !== undefined && CreatedTimeMax !== null) {
            queryParameters = queryParameters.set('CreatedTimeMax', <any>CreatedTimeMax);
        }
        if (CreatedByUuid_Value !== undefined && CreatedByUuid_Value !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.Value', <any>CreatedByUuid_Value);
        }
        if (CreatedByUuid_NotEqual !== undefined && CreatedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('CreatedByUuid.NotEqual', <any>CreatedByUuid_NotEqual);
        }
        if (DeviceUuid_Value !== undefined && DeviceUuid_Value !== null) {
            queryParameters = queryParameters.set('DeviceUuid.Value', <any>DeviceUuid_Value);
        }
        if (DeviceUuid_NotEqual !== undefined && DeviceUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceUuid.NotEqual', <any>DeviceUuid_NotEqual);
        }
        if (DeviceTypeName_Value !== undefined && DeviceTypeName_Value !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.Value', <any>DeviceTypeName_Value);
        }
        if (DeviceTypeName_NotEqual !== undefined && DeviceTypeName_NotEqual !== null) {
            queryParameters = queryParameters.set('DeviceTypeName.NotEqual', <any>DeviceTypeName_NotEqual);
        }
        if (ViewedTimeMin !== undefined && ViewedTimeMin !== null) {
            queryParameters = queryParameters.set('ViewedTimeMin', <any>ViewedTimeMin);
        }
        if (ViewedTimeMax !== undefined && ViewedTimeMax !== null) {
            queryParameters = queryParameters.set('ViewedTimeMax', <any>ViewedTimeMax);
        }
        if (ViewedByUuid_Value !== undefined && ViewedByUuid_Value !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.Value', <any>ViewedByUuid_Value);
        }
        if (ViewedByUuid_NotEqual !== undefined && ViewedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('ViewedByUuid.NotEqual', <any>ViewedByUuid_NotEqual);
        }
        if (ViewedIsNull !== undefined && ViewedIsNull !== null) {
            queryParameters = queryParameters.set('ViewedIsNull', <any>ViewedIsNull);
        }
        if (AcknowledgedTimeMin !== undefined && AcknowledgedTimeMin !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMin', <any>AcknowledgedTimeMin);
        }
        if (AcknowledgedTimeMax !== undefined && AcknowledgedTimeMax !== null) {
            queryParameters = queryParameters.set('AcknowledgedTimeMax', <any>AcknowledgedTimeMax);
        }
        if (AcknowledgedByUuid_Value !== undefined && AcknowledgedByUuid_Value !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.Value', <any>AcknowledgedByUuid_Value);
        }
        if (AcknowledgedByUuid_NotEqual !== undefined && AcknowledgedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('AcknowledgedByUuid.NotEqual', <any>AcknowledgedByUuid_NotEqual);
        }
        if (AcknowledgedIsNull !== undefined && AcknowledgedIsNull !== null) {
            queryParameters = queryParameters.set('AcknowledgedIsNull', <any>AcknowledgedIsNull);
        }
        if (FixedTimeMin !== undefined && FixedTimeMin !== null) {
            queryParameters = queryParameters.set('FixedTimeMin', <any>FixedTimeMin);
        }
        if (FixedTimeMax !== undefined && FixedTimeMax !== null) {
            queryParameters = queryParameters.set('FixedTimeMax', <any>FixedTimeMax);
        }
        if (FixedByUuid_Value !== undefined && FixedByUuid_Value !== null) {
            queryParameters = queryParameters.set('FixedByUuid.Value', <any>FixedByUuid_Value);
        }
        if (FixedByUuid_NotEqual !== undefined && FixedByUuid_NotEqual !== null) {
            queryParameters = queryParameters.set('FixedByUuid.NotEqual', <any>FixedByUuid_NotEqual);
        }
        if (FixedIsNull !== undefined && FixedIsNull !== null) {
            queryParameters = queryParameters.set('FixedIsNull', <any>FixedIsNull);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (Offset !== undefined && Offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>Offset);
        }
        if (skiptoken !== undefined && skiptoken !== null) {
            queryParameters = queryParameters.set('skiptoken', <any>skiptoken);
        }
        if (order_by !== undefined && order_by !== null) {
            queryParameters = queryParameters.set('order_by', <any>order_by);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }
        if (sid !== undefined && sid !== null) {
            queryParameters = queryParameters.set('sid', <any>sid);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileStreamObject>('get',`${this.basePath}/v1/Messages/odatacsv/${encodeURIComponent(String(exportFileName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get message overview
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessagesOverview(observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: number; }>;
    public getMessagesOverview(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: number; }>>;
    public getMessagesOverview(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: number; }>>;
    public getMessagesOverview(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: number; }>('get',`${this.basePath}/v1/Messages/overview`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * For testing the indexList, e.g. \&quot;1,2,3\&quot;
     * 
     * @param body message id&#x27;s
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMessages_2(body?: string, observe?: 'body', reportProgress?: boolean): Observable<MessageOutputDto>;
    public getMessages_2(body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MessageOutputDto>>;
    public getMessages_2(body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessageOutputDto>>;
    public getMessages_2(body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MessageOutputDto>('get',`${this.basePath}/v1/Messages/test`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get new messages for visual illustration
     * 
     * @param body message type e.g. &quot;ALRAM&quot; or &quot;DISRUPTION&quot;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNewMessages(body?: Array<EventTypes>, observe?: 'body', reportProgress?: boolean): Observable<Array<MessageOutputDto>>;
    public getNewMessages(body?: Array<EventTypes>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MessageOutputDto>>>;
    public getNewMessages(body?: Array<EventTypes>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageOutputDto>>>;
    public getNewMessages(body?: Array<EventTypes>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<MessageOutputDto>>('post',`${this.basePath}/v1/Messages/new`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reset acknowledge of given messages
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetMessageAcknowledged(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetMessageAcknowledged(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetMessageAcknowledged(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetMessageAcknowledged(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling resetMessageAcknowledged.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/ack/reset/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Disallow any message to be deleted
     * 
     * @param rowId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetMessageDeletedMark(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetMessageDeletedMark(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetMessageDeletedMark(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetMessageDeletedMark(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling resetMessageDeletedMark.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/delete/mark/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reset fixed status of messages
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetMessageFixed(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetMessageFixed(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetMessageFixed(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetMessageFixed(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling resetMessageFixed.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/fix/reset/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reset viewed status
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetMessageViewed(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetMessageViewed(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetMessageViewed(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetMessageViewed(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling resetMessageViewed.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/view/reset/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Acknowledge of given alarm/disruption message
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMessageAcknowledged(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMessageAcknowledged(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMessageAcknowledged(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMessageAcknowledged(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling setMessageAcknowledged.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/ack/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Allow own/any message to be deleted
     * 
     * @param rowId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMessageDeletedMark(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMessageDeletedMark(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMessageDeletedMark(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMessageDeletedMark(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling setMessageDeletedMark.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/delete/mark/reset/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fixed of given alarm/disruption message
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMessageFixed(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMessageFixed(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMessageFixed(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMessageFixed(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling setMessageFixed.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/fix/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Given alarm/disruption message was viewed by the user
     * 
     * @param rowId message id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setMessageViewed(rowId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setMessageViewed(rowId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setMessageViewed(rowId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setMessageViewed(rowId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rowId === null || rowId === undefined) {
            throw new Error('Required parameter rowId was null or undefined when calling setMessageViewed.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/v1/Messages/view/${encodeURIComponent(String(rowId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    public getOdataEndPoint(): string { return `${this.basePath}/v1/Messages/odata`; }
}
